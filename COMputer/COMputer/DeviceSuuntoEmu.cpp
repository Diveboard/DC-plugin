#include "DeviceSuuntoEmu.h"

#include <fcntl.h>


std::wstring s2ws(const std::string& s)
{
 int len;
 int slength = (int)s.length() + 1;
 len = MultiByteToWideChar(CP_ACP, 0, s.c_str(), slength, 0, 0);
 wchar_t* buf = new wchar_t[len];
 MultiByteToWideChar(CP_ACP, 0, s.c_str(), slength, buf, len);
 std::wstring r(buf);
 delete[] buf;
 return r;
}



unsigned char generate_crc(unsigned char *buffer,int len) 
{
  char crc=0;

  while(len--) crc^=*buffer++;
  return crc;
}


DeviceSuuntoEmu::DeviceSuuntoEmu(std::string file)
{
	filename = file;
}


DeviceSuuntoEmu::~DeviceSuuntoEmu(void)
{
}


void DeviceSuuntoEmu::open(void)
{
#ifdef _WIN32
  //struct termios settings;
  bool fSuccess;
  DCB dcb;
  
  hCom = CreateFile(s2ws(filename).c_str(), 
    GENERIC_READ | GENERIC_WRITE, 
    0, 
    NULL, 
    OPEN_EXISTING, 
    0,
    NULL 
    ); 

   if (hCom == INVALID_HANDLE_VALUE) 
   {
       //  Handle the error.
	   //Logger::append ("CreateFile on %s failed with error %d.", filename, GetLastError());
       hCom = NULL;
	   throw std::string("Create file failed");
   }
   
   //  Initialize the DCB structure.
   SecureZeroMemory(&dcb, sizeof(DCB));
   dcb.DCBlength = sizeof(DCB);
   //  Build on the current configuration by first retrieving all current
   //  settings.
   fSuccess = GetCommState(hCom, &dcb);

   	dcb.BaudRate = CBR_2400;
	dcb.ByteSize = 8;
	dcb.Parity = ODDPARITY;
	dcb.StopBits = ONESTOPBIT;

  dcb.fBinary=1; 
  dcb.fParity=1; 
  dcb.fInX = false;
  dcb.fOutX = false;
  dcb.fOutxCtsFlow=false; 
  dcb.fOutxDsrFlow=false; 
  dcb.fDtrControl=DTR_CONTROL_DISABLE; 
  dcb.fDsrSensitivity=0; 
  dcb.fTXContinueOnXoff=0; 
  dcb.fRtsControl=RTS_CONTROL_DISABLE; 

   fSuccess = SetCommState(hCom, &dcb);

   if (!fSuccess) 
   {
      //  Handle the error.
      hCom = NULL;
	  throw "SetCommState failed with error.\n";
   }

   /*
   try {
	   set_dtr(DTR_STATUS_ON);
	   set_rts(RTS_STATUS_OFF);
       Sleep(100);
   } catch (...) {
	   hCom = NULL;
	   throw;
   }*/

#elif __MACH__

	struct termios options;

	hCom = ::open(filename.c_str(), O_RDWR | O_NOCTTY | O_NDELAY);
	fcntl(hCom, F_SETFL, 0);
	
	/* get the current options */
	tcgetattr(hCom, &options);
	
	cfsetspeed(&options, B2400);
	
	/* set raw input, 1 second timeout */
	options.c_cflag = CS8|CREAD|PARENB|PARODD|CLOCAL;
	options.c_iflag = IGNBRK; /* Ignore parity checking */
	options.c_lflag=0;
	options.c_oflag=0;
	
	/* Setup blocking, return on 1 character */
	options.c_cc[VMIN] = 0;
	options.c_cc[VTIME] = 0;
	
	/* Clear the line */
	tcflush(hCom,TCIFLUSH);

	if(tcsetattr(hCom,TCSANOW,&options)!=-1) {
		if(set_dtr(DTR_STATUS_ON) && set_rts(RTS_STATUS_OFF)) {
			usleep(100000);
		}
	}
	else {
		Logger::append("Error while setting properties of Com port");
		return(-1);
	}
	
	unsigned char b;
	while(read_serial(&b,1,2)>0){}
	
#else	
#error Platform not supported

#endif
}


void DeviceSuuntoEmu::run()
{
	bool rval; 
	unsigned char buff[2048];
	unsigned char obuff[2048];
	DWORD out;
	int length;
	unsigned char *answer;

	//memory for 050024
	int len050024 = 6;
	unsigned char ans050024[6] = {0x05, 0x00, 0x24, 0x01, 0x0a, 0x2A};

	int len05 = 48;
	unsigned char ans05[120] = 
	/*{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x3E, 0x59, 0x01, 0xE6, 0x60, 0X00, 0x01, 0x0A, 0x21, 0x02, 0x1E, 0x22, 0x22, 0x00, 0x00, 0x53, 0x75, 0x75, 0x6E, 0x74, 0x6F, 0x20, 0x44, 0x69, 0x76,
		0x65, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00,
		0x06, 0xF1, 0x14, 0x03, 0x0E, 0x05, 0x1F, 0xFF, 0x1F, 0xFF, 0x01, 0x00, 0x00, 0x00 , 0x00 , 0x00 , 0x01 , 0x01 , 0x00 , 0x8F , 0x02 , 0x00 , 0x1E , 0x2A , 0xA8 , 0x46 , 0x23
	};*/
	{0x0E, 0x7A, 0x80, 0x28, 0x01, 0xB0, 0xB6, 0xFF, 0x01, 0xA3, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x28, 0x00, 0x01, 0xA0, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x59,
	0x01, 0xE6, 0x00, 0x09, 0x0A, 0x21, 0x02, 0x1E, 0x22, 0x22, 0x00, 0x00, 0x53, 0x75, 0x75, 0x6E, 0x74, 0x6F, 0x20, 0x44, 0x69, 0x76, 0x65, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xF1, 0x14, 0x03, 0x0E, 0x05, 0x1F, 0xFF, 0x1F, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00
	};


	//answer to 08
	int len08 = 241;
	unsigned char ans08[244] = {0x08, 0x20, 0x00, 0x00, 0x17, 0x14, 0x80, 0x7D, 0xFF, 0xFF, 0xFF, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x01, 0x00, 0x01, 0xFF, 0xFD, 0xFE, 0xFF, 0x01, 0x01, 0x00, 0x02, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0xD5, 0x08, 0x20, 0x01, 0xFD, 0x00, 0x00, 0xFF, 0xFF, 0x01, 0x00, 0xFE, 0xFF, 0xFE, 0x00, 0x01, 0xFE, 0x00, 0x00, 0xFD, 0xFF, 0xFE, 0xFD, 0x01, 0x00, 0xFF, 0xFD, 0x02, 0xFF, 0x00, 0x02, 0x01, 0xFE, 0x00, 0x00, 0xD7, 0x08, 0x20, 0xFF, 0xFC, 0x00, 0xFD, 0xFE, 0x02, 0xFF, 0x01, 0x00, 0x02, 0x00, 0x01, 0x01, 0x02, 0x00, 0x01, 0x00, 0xFF, 0xFF, 0xFF, 0x01, 0x01, 0x00, 0x01, 0xFB, 0xFC, 0x01, 0x02, 0x00, 0x04, 0x00, 0x03, 0x28, 0x08, 0x20, 0xFE, 0xFE, 0xFE, 0xFB, 0xFD, 0xFA, 0xF9, 0xFE, 0x01, 0xFF, 0x00, 0xFD, 0xFF, 0xFE, 0x7E, 0xFF, 0x00, 0x02, 0x05, 0xFE, 0xFF, 0xF8, 0xF7, 0xFA, 0x7A, 0xFF, 0xFF, 0xFF, 0x00, 0x01, 0xFD, 0xFF, 0xDB, 0x08, 0x20, 0x03, 0x04, 0x02, 0xFF, 0x01, 0x04, 0x07, 0x04, 0x01, 0xFE, 0xFD, 0x02, 0x04, 0x00, 0xFC, 0x01, 0x02, 0x05, 0x02, 0x04, 0xFD, 0x01, 0x04, 0x01, 0xFF, 0x00, 0x00, 0x03, 0x00, 0xFE, 0x00, 0x02, 0xD5, 0x08, 0x20, 0x00, 0xFF, 0x02, 0xFE, 0xFD, 0x00, 0x01, 0x00, 0x01, 0xFE, 0x00, 0x02, 0x01, 0xFE, 0x00, 0xFF, 0x00, 0x01, 0xFF, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x04, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x01, 0x2C, 0x08, 0x1C, 0x00, 0x01, 0x02, 0x04, 0x08, 0x03, 0x05, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x0B, 0x22, 0x0E, 0x1F, 0x07, 0x0A, 0x1C, 0x0F, 0x00, 0x00, 0x03, 0x14, 0x09, 0x03, 0x29, 0x08};

	//answer to 09
	int len09 = 3;
	unsigned char ans09[3] = {0x09, 0x00, 0x09};

	while (true)
	{
		try {
			  answer = NULL;

			  rval = ReadFile(hCom, buff, 1, &out, NULL);
			  if (!rval || out != 1)
				  throw "Error while reading first char";

  			  printf("Type of request : %02X\n", buff[0]);

			  switch(buff[0])
			  {
			  case 0x05:
				  rval = ReadFile(hCom, buff+1, 4, &out, NULL);
				  if (!rval || out != 4)
					throw "Error while reading the 4 other chars of 05 command";
				  printf("Received : %02X %02X %02X %02X %02X\n", buff[0], buff[1], buff[2], buff[3], buff[4]);
				  break;
			  case 0x08:
			  case 0x09:
				  rval = ReadFile(hCom, buff+1, 2, &out, NULL);
				  if (!rval || out != 2)
					throw "Error while reading the 2 other chars of 08/09 command";
				  printf("Received : %02X %02X %02X\n", buff[0], buff[1], buff[2]);
				  break;
			  }

			if (buff[0] == 0x05)
			{
				memcpy(obuff, buff, 4);
				memcpy(obuff+4, ans05+buff[2]+16*buff[1],buff[3]);
				obuff[4+buff[3]] = generate_crc(obuff, 4+buff[3]);
				length = 5 + buff[3]; 
				answer = obuff;
			}
			if (buff[0] == 0x08)
			{
				//Logger::append("Choosing answer 0x08");
				length = len08;
				answer = ans08;
			}
			if (buff[0] == 0x09)
			{
				//Logger::append("Choosing answer 0x09");
				length = len09;
				answer = ans09;
			}

			if (answer)
			{
				printf("Sending :\n");

				for (int k=0; k<length; k++)
					if (k%16==15) printf(" %02X\n", answer[k]);
					else printf(" %02X", answer[k]);

				printf("\n");
				Sleep(100);
				//Waiting for CTS to stop before transmitting
				while (true)
				{
					DWORD stat;
					DWORD change;
					if (!GetCommModemStatus(hCom, &stat))
						throw "Error getting line status";
					if (!(stat & MS_CTS_ON))
						break;
					WaitCommEvent(hCom, &change, NULL);
				}

				DWORD  out;
				WriteFile(hCom, answer, length, &out, NULL);
				//Logger::binary("WRITE", buffer, out);
				if (!FlushFileBuffers(hCom))
					throw "Error while flushing";
				if (!PurgeComm (hCom, PURGE_RXABORT | PURGE_RXCLEAR | PURGE_TXABORT | PURGE_TXCLEAR))
					throw "Error while purging";
			}
			else
				printf("ERROR : Don't know what to answer !\n");
		}
		catch(char *s) {printf("Exception caught : %s\n", s);}
		catch(...) {printf("Unknown exception caught\n");}
	}

}




